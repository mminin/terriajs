var __defProp = Object.defineProperty;
var __markAsModule = (target) => __defProp(target, "__esModule", {value: true});
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, {get: all[name], enumerable: true});
};
var __async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};
__markAsModule(exports);
__export(exports, {
  PMTiles: () => PMTiles,
  ProtocolCache: () => ProtocolCache,
  createDirectory: () => createDirectory,
  deriveLeaf: () => deriveLeaf,
  getUint24: () => getUint24,
  getUint48: () => getUint48,
  leafletLayer: () => leafletLayer,
  parseEntry: () => parseEntry,
  parseHeader: () => parseHeader,
  queryLeafLevel: () => queryLeafLevel,
  queryLeafdir: () => queryLeafdir,
  queryTile: () => queryTile,
  shift: () => shift,
  sortDir: () => sortDir,
  unshift: () => unshift
});
const shift = (n, shift2) => {
  return n * Math.pow(2, shift2);
};
const unshift = (n, shift2) => {
  return Math.floor(n / Math.pow(2, shift2));
};
const getUint24 = (view, pos) => {
  return shift(view.getUint16(pos + 1, true), 8) + view.getUint8(pos);
};
const getUint48 = (view, pos) => {
  return shift(view.getUint32(pos + 2, true), 16) + view.getUint16(pos, true);
};
const compare = (tz, tx, ty, view, i) => {
  if (tz != view.getUint8(i))
    return tz - view.getUint8(i);
  const x = getUint24(view, i + 1);
  if (tx != x)
    return tx - x;
  const y = getUint24(view, i + 4);
  if (ty != y)
    return ty - y;
  return 0;
};
const queryLeafdir = (view, z, x, y) => {
  const offset_len = queryView(view, z | 128, x, y);
  if (offset_len) {
    return {
      z,
      x,
      y,
      offset: offset_len[0],
      length: offset_len[1],
      is_dir: true
    };
  }
  return null;
};
const queryTile = (view, z, x, y) => {
  const offset_len = queryView(view, z, x, y);
  if (offset_len) {
    return {
      z,
      x,
      y,
      offset: offset_len[0],
      length: offset_len[1],
      is_dir: false
    };
  }
  return null;
};
const queryView = (view, z, x, y) => {
  let m = 0;
  let n = view.byteLength / 17 - 1;
  while (m <= n) {
    const k = n + m >> 1;
    const cmp = compare(z, x, y, view, k * 17);
    if (cmp > 0) {
      m = k + 1;
    } else if (cmp < 0) {
      n = k - 1;
    } else {
      return [getUint48(view, k * 17 + 7), view.getUint32(k * 17 + 13, true)];
    }
  }
  return null;
};
const queryLeafLevel = (view) => {
  if (view.byteLength < 17)
    return null;
  const numEntries = view.byteLength / 17;
  const entry = parseEntry(view, numEntries - 1);
  if (entry.is_dir)
    return entry.z;
  return null;
};
const entrySort = (a, b) => {
  if (a.is_dir && !b.is_dir) {
    return 1;
  }
  if (!a.is_dir && b.is_dir) {
    return -1;
  }
  if (a.z !== b.z) {
    return a.z - b.z;
  }
  if (a.x !== b.x) {
    return a.x - b.x;
  }
  return a.y - b.y;
};
const parseEntry = (dataview, i) => {
  const z_raw = dataview.getUint8(i * 17);
  const z = z_raw & 127;
  return {
    z,
    x: getUint24(dataview, i * 17 + 1),
    y: getUint24(dataview, i * 17 + 4),
    offset: getUint48(dataview, i * 17 + 7),
    length: dataview.getUint32(i * 17 + 13, true),
    is_dir: z_raw >> 7 === 1
  };
};
const sortDir = (dataview) => {
  const entries = [];
  for (let i = 0; i < dataview.byteLength / 17; i++) {
    entries.push(parseEntry(dataview, i));
  }
  return createDirectory(entries);
};
const createDirectory = (entries) => {
  entries.sort(entrySort);
  const buffer = new ArrayBuffer(17 * entries.length);
  const arr = new Uint8Array(buffer);
  for (let i = 0; i < entries.length; i++) {
    const entry = entries[i];
    let z = entry.z;
    if (entry.is_dir)
      z = z | 128;
    arr[i * 17] = z;
    arr[i * 17 + 1] = entry.x & 255;
    arr[i * 17 + 2] = entry.x >> 8 & 255;
    arr[i * 17 + 3] = entry.x >> 16 & 255;
    arr[i * 17 + 4] = entry.y & 255;
    arr[i * 17 + 5] = entry.y >> 8 & 255;
    arr[i * 17 + 6] = entry.y >> 16 & 255;
    arr[i * 17 + 7] = entry.offset & 255;
    arr[i * 17 + 8] = unshift(entry.offset, 8) & 255;
    arr[i * 17 + 9] = unshift(entry.offset, 16) & 255;
    arr[i * 17 + 10] = unshift(entry.offset, 24) & 255;
    arr[i * 17 + 11] = unshift(entry.offset, 32) & 255;
    arr[i * 17 + 12] = unshift(entry.offset, 48) & 255;
    arr[i * 17 + 13] = entry.length & 255;
    arr[i * 17 + 14] = entry.length >> 8 & 255;
    arr[i * 17 + 15] = entry.length >> 16 & 255;
    arr[i * 17 + 16] = entry.length >> 24 & 255;
  }
  return buffer;
};
const deriveLeaf = (root, tile) => {
  const leaf_level = queryLeafLevel(root.dir);
  if (leaf_level) {
    const level_diff = tile.z - leaf_level;
    const leaf_x = Math.trunc(tile.x / (1 << level_diff));
    const leaf_y = Math.trunc(tile.y / (1 << level_diff));
    return {z: leaf_level, x: leaf_x, y: leaf_y};
  }
  return null;
};
const parseHeader = (dataview) => {
  const magic = dataview.getUint16(0, true);
  if (magic !== 19792) {
    throw new Error('File header does not begin with "PM"');
  }
  const version = dataview.getUint16(2, true);
  const json_size = dataview.getUint32(4, true);
  const root_entries = dataview.getUint16(8, true);
  return {
    version,
    json_size,
    root_entries
  };
};
class PMTiles {
  constructor(url, maxLeaves = 64) {
    this.root = null;
    this.url = url;
    this.leaves = new Map();
    this.maxLeaves = maxLeaves;
  }
  fetchRoot(url) {
    return __async(this, null, function* () {
      const controller = new AbortController();
      const signal = controller.signal;
      const resp = yield fetch(url, {
        signal,
        headers: {Range: "bytes=0-511999"}
      });
      const contentLength = resp.headers.get("Content-Length");
      if (!contentLength || +contentLength !== 512e3) {
        console.error("Content-Length mismatch indicates byte serving not supported; aborting.");
        controller.abort();
      }
      const a = yield resp.arrayBuffer();
      const header = parseHeader(new DataView(a, 0, 10));
      let root_dir = new DataView(a, 10 + header.json_size, 17 * header.root_entries);
      if (header.version === 1) {
        console.warn("Sorting pmtiles v1 directory");
        root_dir = new DataView(sortDir(root_dir));
      }
      return {
        buffer: a,
        header,
        dir: root_dir
      };
    });
  }
  getRoot() {
    return __async(this, null, function* () {
      if (this.root)
        return this.root;
      this.root = this.fetchRoot(this.url);
      return this.root;
    });
  }
  metadata() {
    return __async(this, null, function* () {
      const root = yield this.getRoot();
      const dec = new TextDecoder("utf-8");
      const result = JSON.parse(dec.decode(new DataView(root.buffer, 10, root.header.json_size)));
      if (result.compression) {
        console.warn(`Archive has compression type: ${result.compression} and may not be readable directly by browsers.`);
      }
      if (!result.bounds) {
        console.warn(`Archive is missing 'bounds' in metadata, required in v2 and above.`);
      }
      if (!result.minzoom) {
        console.warn(`Archive is missing 'minzoom' in metadata, required in v2 and above.`);
      }
      if (!result.maxzoom) {
        console.warn(`Archive is missing 'maxzoom' in metadata, required in v2 and above.`);
      }
      return result;
    });
  }
  fetchLeafdir(version, entry) {
    return __async(this, null, function* () {
      const resp = yield fetch(this.url, {
        headers: {
          Range: "bytes=" + entry.offset + "-" + (entry.offset + entry.length - 1)
        }
      });
      let buf = yield resp.arrayBuffer();
      if (version === 1) {
        console.warn("Sorting pmtiles v1 directory.");
        buf = sortDir(new DataView(buf));
      }
      return buf;
    });
  }
  getLeafdir(version, entry) {
    return __async(this, null, function* () {
      const leaf = this.leaves.get(entry.offset);
      if (leaf)
        return yield leaf.buffer;
      const buf = this.fetchLeafdir(version, entry);
      this.leaves.set(entry.offset, {
        lastUsed: performance.now(),
        buffer: buf
      });
      if (this.leaves.size > this.maxLeaves) {
        let minUsed = Infinity;
        let minKey = void 0;
        this.leaves.forEach((val, key) => {
          if (val.lastUsed < minUsed) {
            minUsed = val.lastUsed;
            minKey = key;
          }
        });
        if (minKey)
          this.leaves.delete(minKey);
      }
      return yield buf;
    });
  }
  getZxy(z, x, y) {
    return __async(this, null, function* () {
      const root = yield this.getRoot();
      const entry = queryTile(root.dir, z, x, y);
      if (entry)
        return entry;
      const leafcoords = deriveLeaf(root, {z, x, y});
      if (leafcoords) {
        const leafdir_entry = queryLeafdir(root.dir, leafcoords.z, leafcoords.x, leafcoords.y);
        if (leafdir_entry) {
          const leafdir = yield this.getLeafdir(root.header.version, leafdir_entry);
          return queryTile(new DataView(leafdir), z, x, y);
        }
      }
      return null;
    });
  }
}
const leafletLayer = (source, options) => {
  const cls = L.GridLayer.extend({
    createTile: function(coord, done) {
      const tile = document.createElement("img");
      source.getZxy(coord.z, coord.x, coord.y).then((result) => {
        if (result === null)
          return;
        const controller = new AbortController();
        const signal = controller.signal;
        tile.cancel = () => {
          controller.abort();
        };
        fetch(source.url, {
          signal,
          headers: {
            Range: "bytes=" + result.offset + "-" + (result.offset + result.length - 1)
          }
        }).then((resp) => {
          return resp.arrayBuffer();
        }).then((buf) => {
          const blob = new Blob([buf], {type: "image/png"});
          const imageUrl = window.URL.createObjectURL(blob);
          tile.src = imageUrl;
          tile.cancel = null;
          done(null, tile);
        }).catch((error) => {
          if (error.name !== "AbortError")
            throw error;
        });
      });
      return tile;
    },
    _removeTile: function(key) {
      const tile = this._tiles[key];
      if (!tile) {
        return;
      }
      if (tile.el.cancel)
        tile.el.cancel();
      tile.el.width = 0;
      tile.el.height = 0;
      tile.el.deleted = true;
      L.DomUtil.remove(tile.el);
      delete this._tiles[key];
      this.fire("tileunload", {
        tile: tile.el,
        coords: this._keyToTileCoords(key)
      });
    }
  });
  return new cls(options);
};
class ProtocolCache {
  constructor() {
    this.protocol = (params, callback) => {
      const re = new RegExp(/pmtiles:\/\/(.+)\/(\d+)\/(\d+)\/(\d+)/);
      const result = params.url.match(re);
      const pmtiles_url = result[1];
      let instance = this.tiles.get(pmtiles_url);
      if (!instance) {
        instance = new PMTiles(pmtiles_url);
        this.tiles.set(pmtiles_url, instance);
      }
      const z = result[2];
      const x = result[3];
      const y = result[4];
      let cancel = () => {
      };
      instance.getZxy(+z, +x, +y).then((val) => {
        if (val) {
          const headers = {
            Range: "bytes=" + val.offset + "-" + (val.offset + val.length - 1)
          };
          const controller = new AbortController();
          const signal = controller.signal;
          cancel = () => {
            controller.abort();
          };
          fetch(pmtiles_url, {signal, headers}).then((resp) => {
            return resp.arrayBuffer();
          }).then((arr) => {
            callback(null, arr, null, null);
          }).catch((e) => {
            callback(new Error("Canceled"), null, null, null);
          });
        } else {
          callback(null, new Uint8Array(), null, null);
        }
      });
      return {
        cancel: () => {
          cancel();
        }
      };
    };
    this.tiles = new Map();
  }
  add(p) {
    this.tiles.set(p.url, p);
  }
  get(url) {
    return this.tiles.get(url);
  }
}
