import { Guard } from './types';
declare type NotGuard<A, B extends A> = (a: A) => a is Exclude<A, B>;
declare type GuardedType<T> = T extends (x: any) => x is infer T ? T : never;
/**
 * Takes an array of guard parameters (so should have only one item)
 * and return the first parameter converted to an intersection.
 *
 * @example
  type Guards = ... // some guards

  type GuardsParameters = Parameters\<Guards[number]\>;
  type IntersectionOfInputTypes = InputParametersToIntersection<GuardsParameters>;
 *
 */
declare type InputParametersToIntersection<Params> = (Params extends [any] ? (k: Params[0]) => void : never) extends (k: infer I) => void ? I : never;
export declare function not<A, B extends A>(guard: Guard<A, B>): NotGuard<A, B>;
export declare function and<Guards extends Guard<any, any>[]>(...guards: Guards): (t: InputParametersToIntersection<Parameters<Guards[number]>>) => t is InputParametersToIntersection<Parameters<Guards[number]>> & ((GuardedType<Guards[number]> extends any ? (k: GuardedType<Guards[number]>) => void : never) extends (k: infer I) => void ? I : never);
export declare function or<Guards extends Guard<any, any>[]>(...guards: Guards): (t: InputParametersToIntersection<Parameters<Guards[number]>>) => t is InputParametersToIntersection<Parameters<Guards[number]>> & GuardedType<Guards[number]>;
export {};
