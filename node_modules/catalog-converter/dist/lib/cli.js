"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
var _a, _b;
Object.defineProperty(exports, "__esModule", { value: true });
var fs_1 = __importDefault(require("fs"));
var json5_1 = __importDefault(require("json5"));
var lodash_1 = __importDefault(require("lodash"));
var yargs_1 = __importDefault(require("yargs"));
var ConversionOptions_1 = require("./ConversionOptions");
var convert_1 = require("./convert");
var Message_1 = require("./Message");
var transferIds_1 = require("./transferIds");
// import "core-js/features/object";
var argv = yargs_1.default
    .usage("Usage: $0 source [destination] [options]")
    .demandCommand(1)
    .option("u", {
    alias: "copyUnknownProperties",
    type: "boolean",
    default: ConversionOptions_1.defaultConversionOptions.copyUnknownProperties,
    description: "Copy unknown properties",
})
    .option("a", {
    alias: "aggregate-stats",
    type: "boolean",
    default: false,
    description: "Aggregate error and warning statistics",
})
    .option("p", {
    alias: "noprint-all",
    type: "boolean",
    default: false,
    description: "Disable printing every error and warning",
})
    .option("g", {
    alias: "generate-random-ids",
    type: "boolean",
    default: ConversionOptions_1.defaultConversionOptions.generateIds,
    description: "Generate random IDs for each item in the catalog. If the item already has an ID then it is retained.",
})
    .option("t", {
    alias: "transfer-ids",
    type: "string",
    description: "Transfer IDS from another catalog file.",
})
    .option("l", {
    alias: "id-length",
    type: "number",
    default: ConversionOptions_1.defaultConversionOptions.idLength,
    description: "Length of the generated random IDs",
})
    .help().argv;
var json = json5_1.default.parse(fs_1.default.readFileSync(argv._[0], { encoding: "utf-8" }));
var res = convert_1.convertCatalog(json, {
    copyUnknownProperties: argv.u,
    generateIds: argv.g,
    idLength: argv.l,
});
var errors = res.messages.filter(function (mes) { return mes.severity === Message_1.Severity.Error; });
var warnings = res.messages.filter(function (mes) { return mes.severity === Message_1.Severity.Warning; });
var success = res.result !== null;
var outputMessage = "\n" + (success ? "Succeeded" : "Failed") + " with " + errors.length + " errors and " + warnings.length + " warnings.\n";
if (errors.length || warnings.length) {
    outputMessage +=
        "\nIf you have trouble using the converter, reach out to us at https://github.com/TerriaJS/terriajs/discussions for additional support.\n";
}
console.log(outputMessage);
if (success) {
    // Transfer IDs
    if (argv.t && ((_a = res.result) === null || _a === void 0 ? void 0 : _a.catalog)) {
        var ids = json5_1.default.parse(fs_1.default.readFileSync(argv.t, { encoding: "utf-8" }));
        transferIds_1.transferIds((_b = res.result) === null || _b === void 0 ? void 0 : _b.catalog, ids.catalog);
    }
    var output = JSON.stringify(res.result, null, 2);
    if (argv._[1]) {
        fs_1.default.writeFileSync(argv._[1], output);
    }
    else {
        console.log(output);
    }
}
if (!argv.p) {
    errors.forEach(function (_a) {
        var message = _a.message, path = _a.path;
        console.error("Error: " + message + "\n  in " + path.reverse().join("\n     ") + "\n");
    });
    warnings.forEach(function (_a) {
        var message = _a.message, path = _a.path;
        console.warn("Warning: " + message + "\n  in " + path.reverse().join("\n     ") + "\n");
    });
}
function partitionMessages(messsages) {
    var result = {
        unknownProps: [],
        missingRequiredProps: [],
        unknownTypes: [],
        inputNotPlainObjects: [],
    };
    messsages.forEach(Message_1.foldMessage({
        isUnknownProp: function (m) { return result.unknownProps.push(m); },
        isMissingRequiredProp: function (m) { return result.missingRequiredProps.push(m); },
        isUnknownType: function (m) { return result.unknownTypes.push(m); },
        isInputNotPlainObject: function (m) { return result.inputNotPlainObjects.push(m); },
    }));
    return result;
}
function countMessages(messages) {
    var result = {
        unknownProps: 0,
        missingRequiredProps: 0,
        unknownTypes: 0,
        inputNotPlainObjects: 0,
    };
    messages.forEach(Message_1.foldMessage({
        isUnknownProp: function () { return result.unknownProps++; },
        isMissingRequiredProp: function () { return result.missingRequiredProps++; },
        isUnknownType: function () { return result.unknownTypes++; },
        isInputNotPlainObject: function () { return result.inputNotPlainObjects++; },
    }));
    return result;
}
if (argv.a) {
    console.error("Error stats:\n" + JSON.stringify(countMessages(errors), null, 2));
    console.warn("Warning stats:\n" + JSON.stringify(countMessages(warnings), null, 2));
    var partitionedErrors = partitionMessages(errors);
    var partitionedWarnings = partitionMessages(warnings);
    console.error("Unknown types: " +
        JSON.stringify(lodash_1.default.countBy(partitionedErrors.unknownTypes, function (m) { return Message_1.getUnknownTypeDetails(m).type; }), null, 2));
    var unknownPropsByTypeObject = {};
    partitionedWarnings.unknownProps
        .map(function (m) { return Message_1.getUnknownPropDetails(m); })
        .reduce(function (o, _a) {
        var _b, _c;
        var modelType = _a.modelType, property = _a.property;
        var byModel = o[modelType] || {};
        return Object.assign(o, (_b = {},
            _b[modelType] = Object.assign(byModel, (_c = {},
                _c[property] = (byModel[property] || 0) + 1,
                _c)),
            _b));
    }, unknownPropsByTypeObject);
    console.error("Unknown properties: " + JSON.stringify(unknownPropsByTypeObject, null, 2));
}
//# sourceMappingURL=cli.js.map