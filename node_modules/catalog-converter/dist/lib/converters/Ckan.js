"use strict";
var __spreadArrays = (this && this.__spreadArrays) || function () {
    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
    for (var r = Array(s), k = 0, i = 0; i < il; i++)
        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
            r[k] = a[j];
    return r;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var dist_1 = __importDefault(require("@sindresorhus/is/dist"));
var lodash_1 = require("lodash");
var Message_1 = require("../Message");
var CsvItem_1 = require("./CsvItem");
var helpers_1 = require("./helpers");
var other_1 = require("./other");
var WmsCatalogItem_1 = require("./WmsCatalogItem");
function ckanCatalogGroup(item, options) {
    // See details of what's been ported https://github.com/TerriaJS/terriajs/pull/4160
    if (!options.partial && !dist_1.default.string(item.url)) {
        return helpers_1.nullResult(Message_1.missingRequiredProp(Message_1.ModelType.CkanGroup, "url", "string", item.name));
    }
    var propsToCopy = [
        "url",
        "filterQuery",
        "groupBy",
        "useCombinationNameWhereMultipleResources",
        {
            v7: "ungroupedTitle",
            v8: "ungroupedTitle",
            // Get rid of null values
            translationFn: function (v) { return (v === "" || v === null ? undefined : v); },
        },
    ];
    var unknownProps = helpers_1.getUnknownProps(item, __spreadArrays(helpers_1.catalogMemberProps, helpers_1.catalogMemberPropsIgnore, propsToCopy, [
        "esriMapServerResourceFormat",
        "wmsParameters",
    ]));
    var member = {
        type: "ckan-group",
        name: item.name,
    };
    var messages = helpers_1.propsToWarnings(Message_1.ModelType.CkanGroup, unknownProps, item.name);
    helpers_1.copyProps(item, member, __spreadArrays(helpers_1.catalogMemberProps, propsToCopy));
    if (options.copyUnknownProperties) {
        helpers_1.copyProps(item, member, unknownProps);
    }
    // Convert various configurations now condensed into supported resource formats
    var supportedResourceFormats = [];
    if (dist_1.default.string(item.esriMapServerResourceFormat)) {
        supportedResourceFormats.push({
            id: "ArcGIS FeatureServer",
            formatRegex: item.esriMapServerResourceFormat,
        });
    }
    if (dist_1.default.plainObject(item.wmsParameters)) {
        supportedResourceFormats.push({
            id: "WMS",
            definition: {
                type: "wms",
                parameters: item.wmsParameters,
            },
        });
    }
    member.supportedResourceFormats = supportedResourceFormats;
    return {
        member: member,
        messages: messages,
    };
}
exports.ckanCatalogGroup = ckanCatalogGroup;
function ckanCatalogItem(item, options) {
    if (!options.partial && !dist_1.default.string(item.url)) {
        return helpers_1.nullResult(Message_1.missingRequiredProp(Message_1.ModelType.CkanCatalogItem, "url", "string", item.name));
    }
    // Note, this doesn't use catalogMemberProps (it uses CatalogMemberReferenceTraits intead of CatalogMemberTraits)
    var propsToCopy = [
        "id",
        "name",
        "url",
        "forceProxy",
        "cacheDuration",
        "dataCustodian",
        {
            v7: "rectangle",
            v8: "rectangle",
            translationFn: function (rectangle) {
                return {
                    west: parseFloat(rectangle[0]) || undefined,
                    south: parseFloat(rectangle[1]) || undefined,
                    east: parseFloat(rectangle[2]) || undefined,
                    north: parseFloat(rectangle[3]) || undefined,
                };
            },
        },
        "disablePreview",
        "datasetId",
        "resourceId",
    ];
    var v7CkanProps = __spreadArrays(helpers_1.catalogMemberPropsIgnore, propsToCopy, [
        "allowAnyResourceIfResourceIdNotFound",
        "esriFeatureServerResourceFormat",
        "wmsResourceFormat",
        "wfsResourceFormat",
        "kmlResourceFormat",
        "csvResourceFormat",
        "esriMapServerResourceFormat",
        "esriFeatureServerResourceFormat",
        "geoJsonResourceFormat",
        "czmlResourceFormat",
        "itemProperties",
    ]);
    var unknownProps = helpers_1.getUnknownProps(item, __spreadArrays(v7CkanProps, helpers_1.catalogMemberProps));
    var member = {
        type: "ckan-item",
        name: item.name,
    };
    var messages = helpers_1.propsToWarnings(Message_1.ModelType.CkanCatalogItem, unknownProps, item.name);
    helpers_1.copyProps(item, member, __spreadArrays(propsToCopy));
    if (options.copyUnknownProperties) {
        helpers_1.copyProps(item, member, unknownProps);
    }
    var itemPropertiesHelper = function (converter) {
        if (lodash_1.isPlainObject(item.itemProperties)) {
            var itemPropertiesResult = helpers_1.itemProperties(item, converter, options);
            if (itemPropertiesResult.result)
                member.itemProperties = itemPropertiesResult.result;
            messages.push.apply(messages, itemPropertiesResult.messages);
        }
    };
    // Convert various configurations now condensed into supported resource formats
    var supportedResourceFormats = [];
    if (dist_1.default.string(item.esriFeatureServerResourceFormat)) {
        supportedResourceFormats.push({
            id: "ArcGIS FeatureServer",
            formatRegex: item.esriFeatureServerResourceFormat,
            definition: {
                type: "esri-featureServer",
            },
        });
        itemPropertiesHelper(other_1.esriFeatureServerCatalogItem);
    }
    else if (dist_1.default.string(item.wmsResourceFormat)) {
        supportedResourceFormats.push({
            id: "WMS",
            formatRegex: item.wmsResourceFormat,
            definition: {
                type: "wms",
            },
        });
        itemPropertiesHelper(WmsCatalogItem_1.wmsCatalogItem);
    }
    else if (dist_1.default.string(item.wfsResourceFormat)) {
        supportedResourceFormats.push({
            id: "WFS",
            formatRegex: item.wfsResourceFormat,
            definition: {
                type: "wfs",
            },
        });
        if (lodash_1.isPlainObject(item.itemProperties)) {
            messages.push({
                message: "WFS itemProperties is not supported",
                path: [item.name, "itemProperties (WFS)"],
                severity: Message_1.Severity.Warning,
                details: Message_1.unknownPropOpaque.toOpaque({
                    modelType: Message_1.ModelType.CkanCatalogItem,
                    property: "itemProperties (WFS)",
                }),
            });
        }
    }
    else if (dist_1.default.string(item.kmlResourceFormat)) {
        supportedResourceFormats.push({
            id: "Kml",
            formatRegex: item.kmlResourceFormat,
            definition: {
                type: "kml",
            },
        });
        itemPropertiesHelper(other_1.kmlCatalogItem);
    }
    else if (dist_1.default.string(item.csvResourceFormat)) {
        supportedResourceFormats.push({
            id: "CSV",
            formatRegex: item.csvResourceFormat,
            definition: {
                type: "csv",
            },
        });
        itemPropertiesHelper(CsvItem_1.csvCatalogItem);
    }
    else if (dist_1.default.string(item.esriMapServerResourceFormat)) {
        supportedResourceFormats.push({
            id: "ArcGIS MapServer",
            formatRegex: item.esriMapServerResourceFormat,
            definition: {
                type: "esri-mapServer",
            },
        });
        itemPropertiesHelper(other_1.esriMapServerCatalogItem);
    }
    else if (dist_1.default.string(item.esriFeatureServerResourceFormat)) {
        supportedResourceFormats.push({
            id: "ArcGIS FeatureServer",
            formatRegex: item.esriFeatureServerResourceFormat,
            definition: {
                type: "esri-featureServer",
            },
        });
        itemPropertiesHelper(other_1.esriFeatureServerCatalogItem);
    }
    else if (dist_1.default.string(item.geoJsonResourceFormat)) {
        supportedResourceFormats.push({
            id: "GeoJson",
            formatRegex: item.geoJsonResourceFormat,
            definition: {
                type: "geojson",
            },
        });
        itemPropertiesHelper(other_1.geoJsonCatalogItem);
    }
    else if (dist_1.default.string(item.czmlResourceFormat)) {
        supportedResourceFormats.push({
            id: "Czml",
            formatRegex: item.czmlResourceFormat,
            definition: {
                type: "czml",
            },
        });
        if (lodash_1.isPlainObject(item.itemProperties)) {
            messages.push({
                message: "Czml itemProperties is not supported",
                path: [item.name, "itemProperties (Czml)"],
                severity: Message_1.Severity.Warning,
                details: Message_1.unknownPropOpaque.toOpaque({
                    modelType: Message_1.ModelType.CkanCatalogItem,
                    property: "itemProperties (Czml)",
                }),
            });
        }
    }
    if (lodash_1.isPlainObject(item.itemProperties)) {
        // Copy over left over catalogMemberProps (for example "description") to itemProperties
        var extraItemProperties = {};
        // Copy catalogMemberProps which are NOT v7CkanPropKeys
        var v7CkanPropKeys_1 = v7CkanProps.map(function (catalogProp) {
            return dist_1.default.string(catalogProp) ? catalogProp : catalogProp.v7;
        });
        helpers_1.copyProps(item.itemProperties, extraItemProperties, helpers_1.catalogMemberProps.filter(function (catalogProp) {
            return !v7CkanPropKeys_1.includes(dist_1.default.string(catalogProp) ? catalogProp : catalogProp.v7);
        }));
        // Assign extra props to itemProperties
        if (extraItemProperties !== {}) {
            member.itemProperties = Object.assign(lodash_1.isPlainObject(member.itemProperties)
                ? member.itemProperties
                : {}, extraItemProperties);
        }
    }
    member.supportedResourceFormats = supportedResourceFormats;
    return {
        member: member,
        messages: messages,
    };
}
exports.ckanCatalogItem = ckanCatalogItem;
//# sourceMappingURL=Ckan.js.map