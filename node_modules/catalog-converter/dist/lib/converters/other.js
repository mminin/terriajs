"use strict";
var __spreadArrays = (this && this.__spreadArrays) || function () {
    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
    for (var r = Array(s), k = 0, i = 0; i < il; i++)
        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
            r[k] = a[j];
    return r;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var is_1 = __importDefault(require("@sindresorhus/is"));
var Message_1 = require("../Message");
var generateRandomId_1 = __importDefault(require("./generateRandomId"));
var helpers_1 = require("./helpers");
var WmsCatalogItem_1 = require("./WmsCatalogItem");
// Dependency injection to break circular dependency
function groupFromConvertMembersArray(convertMembersArray) {
    return function group(group, options) {
        if (!options.partial && !is_1.default.array(group.items)) {
            return helpers_1.nullResult(Message_1.missingRequiredProp(Message_1.ModelType.Group, "items", "array", group.name));
        }
        var convertedMembers = is_1.default.array(group.items)
            ? convertMembersArray(group.items, group.name, options)
            : undefined;
        var unknownProps = helpers_1.getUnknownProps(group, __spreadArrays(helpers_1.catalogGroupProps, helpers_1.catalogGroupPropsIgnore));
        var extraPropsMessages = helpers_1.propsToWarnings(Message_1.ModelType.Group, unknownProps, group.name);
        var result = {
            member: {
                id: options.generateIds
                    ? generateRandomId_1.default(options.idLength)
                    : undefined,
                type: "group",
                name: group.name,
                members: convertedMembers === null || convertedMembers === void 0 ? void 0 : convertedMembers.members,
            },
            messages: __spreadArrays(((convertedMembers === null || convertedMembers === void 0 ? void 0 : convertedMembers.messages) || []), extraPropsMessages),
        };
        helpers_1.copyProps(group, result.member, helpers_1.catalogGroupProps);
        if (options.copyUnknownProperties) {
            helpers_1.copyProps(group, result.member, unknownProps);
        }
        return result;
    };
}
exports.groupFromConvertMembersArray = groupFromConvertMembersArray;
function webFeatureServerCatalogGroup(item, options) {
    if (!options.partial && !is_1.default.string(item.url)) {
        return helpers_1.nullResult(Message_1.missingRequiredProp(Message_1.ModelType.WfsGroup, "url", "string", item.name));
    }
    var propsToCopy = ["url"];
    var unknownProps = helpers_1.getUnknownProps(item, __spreadArrays(helpers_1.catalogMemberProps, helpers_1.catalogMemberPropsIgnore, propsToCopy));
    var member = {
        type: "wfs-group",
        name: item.name,
    };
    var messages = helpers_1.propsToWarnings(Message_1.ModelType.WfsGroup, unknownProps, item.name);
    helpers_1.copyProps(item, member, __spreadArrays(helpers_1.catalogMemberProps, propsToCopy));
    if (options.copyUnknownProperties) {
        helpers_1.copyProps(item, member, unknownProps);
    }
    return { member: member, messages: messages };
}
exports.webFeatureServerCatalogGroup = webFeatureServerCatalogGroup;
function sosCatalogItem(item, options) {
    if (!options.partial && !is_1.default.string(item.url)) {
        return helpers_1.nullResult(Message_1.missingRequiredProp(Message_1.ModelType.SosItem, "url", "string", item.name));
    }
    var propsToCopy = [
        "url",
        "proceduresName",
        "observablePropertiesName",
        "startDate",
        "filterByProcedures",
        "stationIdWhitelist",
        "procedures",
        "observableProperties",
    ];
    var unknownProps = helpers_1.getUnknownProps(item, __spreadArrays(helpers_1.catalogMemberProps, helpers_1.catalogMemberPropsIgnore, propsToCopy, [
        "featureInfoTemplate",
    ]));
    var member = {
        type: "sos",
        name: item.name,
    };
    var messages = helpers_1.propsToWarnings(Message_1.ModelType.SosItem, unknownProps, item.name);
    if (is_1.default.string(item.featureInfoTemplate) ||
        is_1.default.plainObject(item.featureInfoTemplate)) {
        var result = helpers_1.featureInfoTemplate(Message_1.ModelType.SosItem, item.name, item.featureInfoTemplate);
        member.featureInfoTemplate = result.result;
        messages.push.apply(messages, result.messages);
    }
    helpers_1.copyProps(item, member, __spreadArrays(helpers_1.catalogMemberProps, propsToCopy));
    if (options.copyUnknownProperties) {
        helpers_1.copyProps(item, member, unknownProps);
    }
    return {
        member: member,
        messages: messages,
    };
}
exports.sosCatalogItem = sosCatalogItem;
function esriCatalogGroup(item, options) {
    if (!options.partial && !is_1.default.string(item.url)) {
        return helpers_1.nullResult(Message_1.missingRequiredProp(Message_1.ModelType.EsriCatalogGroup, "url", "string", item.name));
    }
    var propsToCopy = ["url"];
    var unknownProps = helpers_1.getUnknownProps(item, __spreadArrays(helpers_1.catalogMemberProps, helpers_1.catalogMemberPropsIgnore, propsToCopy));
    var member = {
        type: "esri-group",
        name: item.name,
    };
    var messages = helpers_1.propsToWarnings(Message_1.ModelType.EsriCatalogGroup, unknownProps, item.name);
    helpers_1.copyProps(item, member, __spreadArrays(helpers_1.catalogMemberProps, propsToCopy));
    if (options.copyUnknownProperties) {
        helpers_1.copyProps(item, member, unknownProps);
    }
    // //    not supported in v8
    // if (isPlainObject(item.itemProperties)) {
    //   // Treat itemProperties as esriMapServerCatalogGroup (it can also be esriFeatureServerCatalogGroup - but this isn't implemented in catalog-converter).
    //   const itemPropertiesResult = itemProperties(
    //     item,
    //     esriMapServerCatalogGroup
    //   );
    //   if (itemPropertiesResult.result)
    //     member.itemProperties = itemPropertiesResult.result;
    //   messages.push(...itemPropertiesResult.messages);
    // }
    var tileErrorOpts = WmsCatalogItem_1.tileErrorHandlingOptions(item);
    if (tileErrorOpts !== undefined) {
        member.tileErrorHandlingOptions = tileErrorOpts;
    }
    return {
        member: member,
        messages: messages,
    };
}
exports.esriCatalogGroup = esriCatalogGroup;
function esriMapServerCatalogItem(item, options) {
    if (!options.partial && !is_1.default.string(item.url)) {
        return helpers_1.nullResult(Message_1.missingRequiredProp(Message_1.ModelType.EsriMapServerItem, "url", "string", item.name));
    }
    var propsToCopy = [
        "url",
        "layers",
        "maximumScale",
        "allowFeaturePicking",
        "parameters",
        "tokenUrl",
        "showTilesAfterMessage",
        "maximumScaleBeforeMessage",
    ];
    var unknownProps = helpers_1.getUnknownProps(item, __spreadArrays(helpers_1.catalogMemberProps, helpers_1.catalogMemberPropsIgnore, helpers_1.imageryLayerProps, helpers_1.legendProps, propsToCopy, [
        "featureInfoTemplate",
    ]));
    var member = {
        type: "esri-mapServer",
        name: item.name,
    };
    var messages = helpers_1.propsToWarnings(Message_1.ModelType.EsriMapServerItem, unknownProps, item.name);
    if (is_1.default.string(item.featureInfoTemplate) ||
        is_1.default.plainObject(item.featureInfoTemplate)) {
        var result = helpers_1.featureInfoTemplate(Message_1.ModelType.EsriMapServerItem, item.name, item.featureInfoTemplate);
        member.featureInfoTemplate = result.result;
        messages.push.apply(messages, result.messages);
    }
    helpers_1.copyProps(item, member, __spreadArrays(helpers_1.catalogMemberProps, propsToCopy, helpers_1.imageryLayerProps));
    if (options.copyUnknownProperties) {
        helpers_1.copyProps(item, member, unknownProps);
    }
    var legendResult = helpers_1.legends(Message_1.ModelType.WmsItem, item.name, item);
    member.legends = legendResult.result;
    messages.push.apply(messages, legendResult.messages);
    return {
        member: member,
        messages: messages,
    };
}
exports.esriMapServerCatalogItem = esriMapServerCatalogItem;
function esriFeatureServerCatalogItem(item, options) {
    if (!options.partial && !is_1.default.string(item.url)) {
        return helpers_1.nullResult(Message_1.missingRequiredProp(Message_1.ModelType.EsriFeatureServerItem, "url", "string", item.name));
    }
    var propsToCopy = ["url", "useStyleInformationFromService"];
    var unknownProps = helpers_1.getUnknownProps(item, __spreadArrays(helpers_1.catalogMemberProps, helpers_1.catalogMemberPropsIgnore, propsToCopy, [
        "featureInfoTemplate",
    ]));
    var member = {
        type: "esri-featureServer",
        name: item.name,
    };
    var messages = helpers_1.propsToWarnings(Message_1.ModelType.EsriFeatureServerItem, unknownProps, item.name);
    if (is_1.default.string(item.featureInfoTemplate) ||
        is_1.default.plainObject(item.featureInfoTemplate)) {
        var result = helpers_1.featureInfoTemplate(Message_1.ModelType.EsriFeatureServerItem, item.name, item.featureInfoTemplate);
        member.featureInfoTemplate = result.result;
        messages.push.apply(messages, result.messages);
    }
    helpers_1.copyProps(item, member, __spreadArrays(helpers_1.catalogMemberProps, propsToCopy));
    if (options.copyUnknownProperties) {
        helpers_1.copyProps(item, member, unknownProps);
    }
    return {
        member: member,
        messages: messages,
    };
}
exports.esriFeatureServerCatalogItem = esriFeatureServerCatalogItem;
function esriMapServerCatalogGroup(item, options) {
    if (!options.partial && !is_1.default.string(item.url)) {
        return helpers_1.nullResult(Message_1.missingRequiredProp(Message_1.ModelType.EsriMapServerGroup, "url", "string", item.name));
    }
    var propsToCopy = ["url"];
    var unknownProps = helpers_1.getUnknownProps(item, __spreadArrays(helpers_1.catalogMemberProps, helpers_1.catalogMemberPropsIgnore, propsToCopy));
    var member = {
        type: "esri-mapServer-group",
        name: item.name,
    };
    var messages = helpers_1.propsToWarnings(Message_1.ModelType.EsriMapServerGroup, unknownProps, item.name);
    helpers_1.copyProps(item, member, __spreadArrays(helpers_1.catalogMemberProps, propsToCopy));
    if (options.copyUnknownProperties) {
        helpers_1.copyProps(item, member, unknownProps);
    }
    // itemProperties not supported in v8
    // if (isPlainObject(item.itemProperties)) {
    //   const itemPropertiesResult = itemProperties(item, esriMapServerCatalogItem);
    //   if (itemPropertiesResult.result)
    //     member.itemProperties = itemPropertiesResult.result;
    //   messages.push(...itemPropertiesResult.messages);
    // }
    return { member: member, messages: messages };
}
exports.esriMapServerCatalogGroup = esriMapServerCatalogGroup;
// Write properly
function geoJsonCatalogItem(item, options) {
    if (!options.partial &&
        !is_1.default.plainObject(item.data) &&
        !is_1.default.string(item.data) &&
        !is_1.default.string(item.url)) {
        return {
            member: null,
            messages: [
                Message_1.missingRequiredProp(Message_1.ModelType.GeoJsonItem, ["url", "data"], undefined, item.name),
            ],
        };
    }
    var propsToCopy = ["url", "opacity"];
    var unknownProps = helpers_1.getUnknownProps(item, __spreadArrays(helpers_1.catalogMemberProps, helpers_1.catalogMemberPropsIgnore, propsToCopy, helpers_1.legendProps, [
        "data",
        "featureInfoTemplate",
    ]));
    var member = {
        type: "geojson",
        name: item.name,
    };
    var messages = helpers_1.propsToWarnings(Message_1.ModelType.GeoJsonItem, unknownProps, item.name);
    if (options.copyUnknownProperties) {
        helpers_1.copyProps(item, member, unknownProps);
    }
    helpers_1.copyProps(item, member, __spreadArrays(helpers_1.catalogMemberProps, propsToCopy));
    if (is_1.default.string(item.featureInfoTemplate) ||
        is_1.default.plainObject(item.featureInfoTemplate)) {
        var result = helpers_1.featureInfoTemplate(Message_1.ModelType.GeoJsonItem, item.name, item.featureInfoTemplate);
        member.featureInfoTemplate = result.result;
        messages.push.apply(messages, result.messages);
    }
    if (is_1.default.plainObject(item.data)) {
        member.geoJsonData = item.data;
    }
    else if (is_1.default.string(item.data)) {
        member.geoJsonString = item.data;
    }
    var legendResult = helpers_1.legends(Message_1.ModelType.WmsItem, item.name, item);
    member.legends = legendResult.result;
    messages.push.apply(messages, legendResult.messages);
    return { member: member, messages: messages };
}
exports.geoJsonCatalogItem = geoJsonCatalogItem;
function cartoMapCatalogItem(item, options) {
    var member = {
        type: "carto",
        name: item.name,
    };
    var propsToCopy = [
        "config",
        "auth_token",
        "minimumLevel",
        "maximumLevel",
        "attribution",
    ];
    var unknownProps = helpers_1.getUnknownProps(item, __spreadArrays(helpers_1.catalogMemberProps, helpers_1.catalogMemberPropsIgnore, helpers_1.imageryLayerProps, helpers_1.legendProps, propsToCopy));
    var messages = helpers_1.propsToWarnings(Message_1.ModelType.CartoMapCatalogItem, unknownProps, item.name);
    if (options.copyUnknownProperties) {
        helpers_1.copyProps(item, member, unknownProps);
    }
    helpers_1.copyProps(item, member, __spreadArrays(helpers_1.catalogMemberProps, helpers_1.imageryLayerProps, propsToCopy));
    var legendResult = helpers_1.legends(Message_1.ModelType.CartoMapCatalogItem, item.name, item);
    member.legends = legendResult.result;
    messages.push.apply(messages, legendResult.messages);
    return { member: member, messages: messages };
}
exports.cartoMapCatalogItem = cartoMapCatalogItem;
function mapboxVectorTileCatalogItem(item, options) {
    var member = {
        type: "mvt",
        name: item.name,
    };
    var propsToCopy = [
        "lineColor",
        "fillColor",
        "layer",
        "idProperty",
        "nameProperty",
        "maximumNativeZoom",
        "maximumZoom",
        "minimumZoom",
    ];
    var unknownProps = helpers_1.getUnknownProps(item, __spreadArrays(helpers_1.catalogMemberProps, helpers_1.catalogMemberPropsIgnore, helpers_1.imageryLayerProps, helpers_1.legendProps, propsToCopy));
    var messages = helpers_1.propsToWarnings(Message_1.ModelType.MapboxVectorTileCatalogItem, unknownProps, item.name);
    if (options.copyUnknownProperties) {
        helpers_1.copyProps(item, member, unknownProps);
    }
    helpers_1.copyProps(item, member, __spreadArrays(helpers_1.catalogMemberProps, helpers_1.imageryLayerProps, propsToCopy));
    var legendResult = helpers_1.legends(Message_1.ModelType.MapboxVectorTileCatalogItem, item.name, item);
    member.legends = legendResult.result;
    messages.push.apply(messages, legendResult.messages);
    return { member: member, messages: messages };
}
exports.mapboxVectorTileCatalogItem = mapboxVectorTileCatalogItem;
function kmlCatalogItem(item, options) {
    if (!options.partial && !is_1.default.string(item.url)) {
        return helpers_1.nullResult(Message_1.missingRequiredProp(Message_1.ModelType.KmlCatalogItem, "url", "string", item.name));
    }
    var member = {
        type: "kml",
        name: item.name,
    };
    var unknownProps = helpers_1.getUnknownProps(item, __spreadArrays(helpers_1.catalogMemberProps, helpers_1.catalogMemberPropsIgnore, helpers_1.legendProps));
    var messages = helpers_1.propsToWarnings(Message_1.ModelType.KmlCatalogItem, unknownProps, item.name);
    if (options.copyUnknownProperties) {
        helpers_1.copyProps(item, member, unknownProps);
    }
    helpers_1.copyProps(item, member, helpers_1.catalogMemberProps);
    var legendResult = helpers_1.legends(Message_1.ModelType.KmlCatalogItem, item.name, item);
    member.legends = legendResult.result;
    messages.push.apply(messages, legendResult.messages);
    return { member: member, messages: messages };
}
exports.kmlCatalogItem = kmlCatalogItem;
function socrataCatalogGroup(item, options) {
    if (!options.partial && !is_1.default.string(item.url)) {
        return helpers_1.nullResult(Message_1.missingRequiredProp(Message_1.ModelType.SocrataCatalogGroup, "url", "string", item.name));
    }
    var member = {
        type: "socrata-group",
        name: item.name,
    };
    var propsToCopy = [
        {
            v7: "filterQuery",
            v8: "filterQuery",
            // Transform string[] to JsonObject
            // eg ["prop=Value"] to {prop:"Value"}
            translationFn: function (f) {
                return f.reduce(function (obj, curr) {
                    var split = curr.split("=");
                    obj[split[0]] = split[1];
                    return obj;
                }, {});
            },
        },
    ];
    var propsIgnore = ["groupBy"];
    var unknownProps = helpers_1.getUnknownProps(item, __spreadArrays(propsToCopy, propsIgnore, helpers_1.catalogGroupProps, helpers_1.catalogGroupPropsIgnore));
    var messages = helpers_1.propsToWarnings(Message_1.ModelType.SocrataCatalogGroup, unknownProps, item.name);
    if (options.copyUnknownProperties) {
        helpers_1.copyProps(item, member, unknownProps);
    }
    helpers_1.copyProps(item, member, __spreadArrays(helpers_1.catalogGroupProps, propsToCopy));
    return { member: member, messages: messages };
}
exports.socrataCatalogGroup = socrataCatalogGroup;
//# sourceMappingURL=other.js.map