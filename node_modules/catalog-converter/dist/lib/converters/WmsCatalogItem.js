"use strict";
var __spreadArrays = (this && this.__spreadArrays) || function () {
    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
    for (var r = Array(s), k = 0, i = 0; i < il; i++)
        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
            r[k] = a[j];
    return r;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var dist_1 = __importDefault(require("@sindresorhus/is/dist"));
var Message_1 = require("../Message");
var helpers_1 = require("./helpers");
function wmsCatalogItem(item, options) {
    var error;
    if (!dist_1.default.string(item.url)) {
        error = Message_1.missingRequiredProp(Message_1.ModelType.WmsItem, "url", "string", item.name);
    }
    else if (!dist_1.default.string(item.layers)) {
        error = Message_1.missingRequiredProp(Message_1.ModelType.WmsItem, "layers", "string", item.name);
    }
    if (!options.partial && error) {
        return {
            member: null,
            messages: [error],
        };
    }
    var propsToCopy = [
        "layers",
        "styles",
        {
            v7: "availableStyles",
            v8: "availableStyles",
            translationFn: function (availableStyles) {
                return Object.entries(availableStyles).map(function (_a) {
                    var layerName = _a[0], styles = _a[1];
                    var v8Styles = styles.map(function (style) {
                        return {
                            name: style.Name,
                            title: style.Title,
                            abstract: style.Abstract,
                            legend: { url: style.legendUri },
                        };
                    });
                    return {
                        layerName: layerName,
                        styles: v8Styles,
                    };
                });
            },
        },
        "dimensions",
        {
            v7: "availableDimensions",
            v8: "availableDimensions",
            translationFn: function (availableDimensions) {
                return Object.entries(availableDimensions).map(function (_a) {
                    var layerName = _a[0], dimensions = _a[1];
                    var v8Dimensions = dimensions.map(function (dim) {
                        return {
                            name: dim.name,
                            values: dim.options,
                            units: dim.units,
                            unitSymbol: dim.unitSymbol,
                            default: dim.default,
                            multipleValues: dim.multipleValues,
                            nearestValue: dim.nearestValue,
                        };
                    });
                    return {
                        layerName: layerName,
                        dimensions: v8Dimensions,
                    };
                });
            },
        },
        "parameters",
        "linkedWcsUrl",
        "linkedWcsCoverage",
        "chartColor",
        "getCapabilitiesUrl",
        { v7: "featureTimesProperty", v8: "timeFilterPropertyName" },
        "isGeoServer",
        "minScaleDenominator",
        "hideLayerAfterMinScaleDenominator",
        "maxRefreshIntervals",
        "leafletUpdateInterval",
        {
            v7: "supportsColorScaleRange",
            v8: "supportsColorScaleRange",
            translationFn: function (b) {
                return typeof b === "string"
                    ? Boolean(b)
                    : typeof b === "boolean"
                        ? b
                        : undefined;
            },
        },
        {
            v7: "colorScaleMinimum",
            v8: "colorScaleMinimum",
            translationFn: function (b) {
                return typeof b === "string" ? parseFloat(b) : b;
            },
        },
        {
            v7: "colorScaleMaximum",
            v8: "colorScaleMaximum",
            translationFn: function (b) {
                return typeof b === "string" ? parseFloat(b) : b;
            },
        },
        { v7: "disableUserChanges", v8: "disableDimensionSelectors" },
    ];
    var unknownProps = helpers_1.getUnknownProps(item, __spreadArrays(helpers_1.catalogMemberProps, helpers_1.catalogMemberPropsIgnore, helpers_1.imageryLayerProps, helpers_1.legendProps, propsToCopy, [
        "chartType",
        "featureInfoTemplate",
        "ignoreUnknownTileErrors",
        "treat403AsError",
        "treat403AsError",
        "tileErrorThresholdBeforeDisabling",
    ]));
    var member = {
        type: "wms",
        name: item.name,
    };
    var messages = helpers_1.propsToWarnings(Message_1.ModelType.WmsItem, unknownProps, item.name);
    if (options.copyUnknownProperties) {
        helpers_1.copyProps(item, member, unknownProps);
    }
    helpers_1.copyProps(item, member, __spreadArrays(helpers_1.catalogMemberProps, propsToCopy));
    if (item.chartType === "momentPoints") {
        member.chartType = "momentPoints";
    }
    else if (item.chartType === "moment") {
        member.chartType = "momentLines";
    }
    else if (item.chartType !== undefined) {
        throw "Chart type " + member.chartType + " not supported";
    }
    if (dist_1.default.string(item.featureInfoTemplate) ||
        dist_1.default.plainObject(item.featureInfoTemplate)) {
        var result = helpers_1.featureInfoTemplate(Message_1.ModelType.WmsItem, item.name, item.featureInfoTemplate);
        member.featureInfoTemplate = result.result;
        messages.push.apply(messages, result.messages);
    }
    var legendResult = helpers_1.legends(Message_1.ModelType.WmsItem, item.name, item);
    member.legends = legendResult.result;
    messages.push.apply(messages, legendResult.messages);
    var tileErrorOpts = tileErrorHandlingOptions(item);
    if (tileErrorOpts !== undefined) {
        member.tileErrorHandlingOptions = tileErrorOpts;
    }
    return { member: member, messages: messages };
}
exports.wmsCatalogItem = wmsCatalogItem;
function tileErrorHandlingOptions(item) {
    var opts = {};
    if (dist_1.default.boolean(item.treat403AsError)) {
        opts.treat403AsError = item.treat403AsError;
    }
    if (dist_1.default.boolean(item.treat404AsError)) {
        opts.treat404AsError = item.treat404AsError;
    }
    if (dist_1.default.boolean(item.ignoreUnknownTileErrors)) {
        opts.ignoreUnknownTileErrors = item.ignoreUnknownTileErrors;
    }
    if (dist_1.default.number(item.tileErrorThresholdBeforeDisabling)) {
        opts.thresholdBeforeDisablingItem = item.tileErrorThresholdBeforeDisabling;
    }
    return dist_1.default.emptyObject(opts) ? undefined : opts;
}
exports.tileErrorHandlingOptions = tileErrorHandlingOptions;
//# sourceMappingURL=WmsCatalogItem.js.map