"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __spreadArrays = (this && this.__spreadArrays) || function () {
    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
    for (var r = Array(s), k = 0, i = 0; i < il; i++)
        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
            r[k] = a[j];
    return r;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var is_1 = __importDefault(require("@sindresorhus/is"));
var Message_1 = require("../Message");
var helpers_1 = require("./helpers");
var knownTableStyleProps = ["dataVariable", "columns"];
var knownColumnProps = [
    "type",
    "units",
    "name",
    "title",
    "format",
    "replaceWithNullValues",
    "replaceWithZeroValues",
];
var knownColorProps = [
    "nullColor",
    "nullLabel",
    "colorBins",
    "colorMap",
    "numberOfBins",
    "colorPalette",
];
var knownTimeProps = ["timeColumn"];
function tableStyle(item) {
    var _a;
    var tableStyle = item.tableStyle;
    var knownProps = __spreadArrays(knownTableStyleProps, knownColumnProps, knownColorProps, knownTimeProps);
    var unknownProps = helpers_1.getUnknownProps(tableStyle, knownProps);
    var extraProps = {};
    if (is_1.default.plainObject(tableStyle.columns)) {
        var columns = tableStyle.columns;
        Object.entries(columns).map(function (_a, i) {
            var _name = _a[0], defn = _a[1];
            var unknownColumnProps = helpers_1.getUnknownProps(defn, __spreadArrays(knownColumnProps, knownColorProps, knownTimeProps)).map(function (prop) { return "columns[" + i + "]." + prop; });
            unknownProps.push.apply(unknownProps, unknownColumnProps);
        });
        extraProps.columns = Object.entries(columns).map(function (_a) {
            var name = _a[0], defn = _a[1];
            return (__assign({ name: name }, getColumnTraits(defn)));
        });
        extraProps.styles = Object.entries(columns)
            .filter(function (_a) {
            var _name = _a[0], defn = _a[1];
            return is_1.default.plainObject(defn);
        })
            .map(function (_a) {
            var name = _a[0], defn = _a[1];
            return ({
                id: name,
                color: getColorTraits(defn),
                time: getTimeTraits(defn),
            });
        })
            // Filter out styles which have no properties other than `id`
            .filter(function (style) { return style.color || style.time; });
        var chartLines = getChartLines(tableStyle.columns);
        if (chartLines) {
            extraProps.defaultStyle = { chart: { lines: chartLines } };
        }
    }
    if (is_1.default.string(tableStyle.dataVariable)) {
        extraProps.activeStyle = tableStyle.dataVariable;
    }
    var defaultColumn = getColumnTraits(tableStyle);
    if (!is_1.default.emptyObject(defaultColumn)) {
        extraProps.defaultColumn = defaultColumn;
    }
    var extraTimeTraits = ["idColumns", "timeColumn", "isSampled"].reduce(function (acc, prop) {
        if (item[prop]) {
            acc[prop] = item[prop];
        }
        return acc;
    }, {});
    extraProps.defaultStyle = __assign(__assign({}, extraProps.defaultStyle), { time: __assign(__assign({}, ((_a = getTimeTraits(tableStyle)) !== null && _a !== void 0 ? _a : {})), extraTimeTraits) });
    var colorTraits = getColorTraits(tableStyle);
    if (colorTraits) {
        extraProps.defaultStyle = __assign(__assign({}, extraProps.defaultStyle), { color: colorTraits });
    }
    helpers_1.clearEmpties(extraProps);
    return {
        tableStyle: extraProps,
        unknownProps: unknownProps.map(function (prop) { return "tableStyle." + prop; }),
    };
}
function getColumnTraits(defn) {
    var newDefn = {};
    if (is_1.default.plainObject(defn)) {
        if (typeof defn.type === "string" && defn.type.toLowerCase() === "hidden") {
            newDefn.type = "hidden";
        }
        if (is_1.default.string(defn.units)) {
            newDefn.units = defn.units;
        }
        if (is_1.default.string(defn.title)) {
            newDefn.title = defn.title;
        }
        else if (is_1.default.string(defn.name)) {
            newDefn.title = defn.name;
        }
        if (is_1.default.plainObject(defn.format)) {
            newDefn.format = defn.format;
        }
        if (is_1.default.array(defn.replaceWithZeroValues)) {
            newDefn.replaceWithZeroValues = defn.replaceWithZeroValues;
        }
        if (is_1.default.array(defn.replaceWithNullValues)) {
            newDefn.replaceWithNullValues = defn.replaceWithNullValues;
        }
    }
    return newDefn;
}
function getTimeTraits(tableStyle) {
    var timeTraits = {};
    if (is_1.default.string(tableStyle.timeColumn))
        timeTraits.timeColumn = tableStyle.timeColumn;
    else if (is_1.default.array(tableStyle.timeColumn)) {
        var _a = tableStyle.timeColumn, startTimeColumn = _a[0], endTimeColumn = _a[1];
        if (is_1.default.string(startTimeColumn) && is_1.default.string(endTimeColumn)) {
            timeTraits.timeColumn = startTimeColumn;
            timeTraits.endTimeColumn = endTimeColumn;
        }
    }
    else if (is_1.default.null_(tableStyle.timeColumn)) {
        timeTraits.timeColumn = null;
    }
    return is_1.default.emptyObject(timeTraits) ? undefined : timeTraits;
}
function getChartLines(columns) {
    var lines = [];
    Object.entries(columns).forEach(function (_a) {
        var columnName = _a[0], col = _a[1];
        var line = {};
        var chartLineColor = col.chartLineColor, yAxisMin = col.yAxisMin, yAxisMax = col.yAxisMax, active = col.active;
        if (is_1.default.string(chartLineColor))
            line.color = chartLineColor;
        if (is_1.default.number(yAxisMin))
            line.yAxisMinimum = yAxisMin;
        if (is_1.default.number(yAxisMax))
            line.yAxisMaximum = yAxisMax;
        if (is_1.default.boolean(active))
            line.isSelectedInWorkbench = active;
        if (!is_1.default.emptyObject(line))
            line.yAxisColumn = columnName;
        if (!is_1.default.emptyObject(line))
            lines.push(line);
    });
    return is_1.default.emptyArray(lines) ? undefined : lines;
}
function getColorTraits(tableStyle) {
    var _a;
    var color = {};
    if (is_1.default.string(tableStyle.nullColor))
        color.nullColor = tableStyle.nullColor;
    if (is_1.default.string(tableStyle.nullLabel))
        color.nullLabel = tableStyle.nullLabel;
    /*  colorBins can be three things:
     *  - Number, how many colors (color "bins") you want to divide the data into
     *  - Array of number, eg. [3000, 3100, 3800, 3850, 3950, 4000], for boundaries
     *  - Array of color/value pais for enum maps -
     *    For example {
     *                  "color": "yellow",
     *                  "value": "Both CHAdeMO & CCS Combo 2/SAE"
     *                }
     */
    // Note: don't copy value over if 0 - this is used to disable binning in v7 (which isn't supported in v8)
    if (is_1.default.number(tableStyle.colorBins) && tableStyle.colorBins !== 0)
        color.numberOfBins = tableStyle.colorBins;
    else if (is_1.default.array(tableStyle.colorBins) && tableStyle.colorBins.length > 0) {
        if (is_1.default.number(tableStyle.colorBins[0])) {
            color.binMaximums = tableStyle.colorBins;
        }
        else if (is_1.default.string(tableStyle.colorBins[0].color) &&
            is_1.default.string(tableStyle.colorBins[0].value)) {
            color.enumColors = tableStyle.colorBins;
        }
    }
    /*  colorMap can be three things:
     *  - String, eg. 'red-black'
     *  - Array of strings, eg. ['red', 'black']
     *  - Array of objects with the properties 'color' and 'offset', eg. [{color: 'red', offset: 0}, ...].
     *    - v8 only supports array of strings, so 'offset' is discarded
     */
    if (is_1.default.string(tableStyle.colorMap))
        color.binColors = tableStyle.colorMap.split("-");
    if (is_1.default.array(tableStyle.colorMap)) {
        if (typeof tableStyle.colorMap[0] == "string") {
            color.binColors = tableStyle.colorMap;
        }
        else {
            color.binColors = tableStyle.colorMap.reduce(function (binColors, current) {
                return typeof current.color === "string"
                    ? binColors.concat(current.color)
                    : binColors;
            }, []);
        }
    }
    // If we have binColors and numberOfBins is unset, we need to set it manually
    if (color.binColors && is_1.default.nullOrUndefined(color.numberOfBins)) {
        color.numberOfBins = color.binColors.length;
    }
    // Remove "n-class" string before palette (eg "9-class RdYlGn")
    if (is_1.default.string(tableStyle.colorPalette)) {
        var match = tableStyle.colorPalette.match(/([0-9]+)-class /);
        var numberOfBins = parseInt((_a = match === null || match === void 0 ? void 0 : match[1]) !== null && _a !== void 0 ? _a : "", 10);
        if (numberOfBins) {
            color.numberOfBins = numberOfBins;
            color.colorPalette = tableStyle.colorPalette.replace(match[0], "");
        }
        else {
            color.colorPalette = tableStyle.colorPalette;
        }
    }
    return is_1.default.emptyObject(color) ? undefined : color;
}
function csvCatalogItem(item, options) {
    if (!options.partial && !is_1.default.string(item.url) && !is_1.default.string(item.data)) {
        return helpers_1.nullResult(Message_1.missingRequiredProp(Message_1.ModelType.CsvItem, ["url", "data"], undefined, item.name));
    }
    var propsToCopy = [
        "url",
        "opacity",
        { v7: "data", v8: "csvString" },
        { v7: "showWarnings", v8: "showUnmatchedRegionsWarning" },
        {
            v7: "polling",
            v8: "polling",
            translationFn: translatePolling,
        },
    ];
    var unknownProps = helpers_1.getUnknownProps(item, __spreadArrays(helpers_1.catalogMemberProps, helpers_1.catalogMemberPropsIgnore, propsToCopy, [
        "tableStyle",
        "featureInfoTemplate",
        "idColumns",
        "timeColumn",
        "isSampled",
    ]));
    var messages = helpers_1.propsToWarnings(Message_1.ModelType.CsvItem, unknownProps, item.name);
    var member = {
        type: "csv",
        name: item.name,
    };
    if (options.copyUnknownProperties) {
        helpers_1.copyProps(item, member, unknownProps);
    }
    helpers_1.copyProps(item, member, __spreadArrays(helpers_1.catalogMemberProps, propsToCopy));
    if (is_1.default.plainObject(item.tableStyle)) {
        var result = tableStyle(item);
        Object.assign(member, result.tableStyle);
        messages.push.apply(messages, helpers_1.propsToWarnings(Message_1.ModelType.CsvItem, result.unknownProps, item.name));
    }
    if (is_1.default.string(item.featureInfoTemplate) ||
        is_1.default.plainObject(item.featureInfoTemplate)) {
        var result = helpers_1.featureInfoTemplate(Message_1.ModelType.WmsItem, item.name, item.featureInfoTemplate);
        member.featureInfoTemplate = result.result;
        messages.push.apply(messages, result.messages);
    }
    return { member: member, messages: messages };
}
exports.csvCatalogItem = csvCatalogItem;
function translatePolling(polling) {
    var result = {};
    var url = polling.url, seconds = polling.seconds, replace = polling.replace;
    if (is_1.default.string(url))
        result.url = url;
    if (is_1.default.number(seconds))
        result.seconds = seconds;
    if (is_1.default.boolean(replace))
        result.shouldReplaceData = replace;
    return result;
}
//# sourceMappingURL=CsvItem.js.map