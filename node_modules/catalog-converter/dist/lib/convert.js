"use strict";
// Import here Polyfills if needed. Recommended core-js (npm i -D core-js)
// import "core-js/fn/array.find"
// ...
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __spreadArrays = (this && this.__spreadArrays) || function () {
    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
    for (var r = Array(s), k = 0, i = 0; i < il; i++)
        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
            r[k] = a[j];
    return r;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
// Write a function to turn an old catalog into a new catalog
// Unfortunately types in `is` require @types/node to be pinned to v12
// See https://github.com/sindresorhus/is/issues/108
var is_1 = __importDefault(require("@sindresorhus/is"));
var lodash_1 = require("lodash");
var ConversionOptions_1 = require("./ConversionOptions");
var Ckan_1 = require("./converters/Ckan");
var CsvItem_1 = require("./converters/CsvItem");
var Csw_1 = require("./converters/Csw");
var generateRandomId_1 = __importDefault(require("./converters/generateRandomId"));
var helpers_1 = require("./converters/helpers");
var other_1 = require("./converters/other");
var WmsCatalogGroup_1 = require("./converters/WmsCatalogGroup");
var WmsCatalogItem_1 = require("./converters/WmsCatalogItem");
var Wps_1 = require("./converters/Wps");
var Message_1 = require("./Message");
exports.foldMessage = Message_1.foldMessage;
exports.getInputNotPlainObjectDetails = Message_1.getInputNotPlainObjectDetails;
exports.getMissingRequiredPropDetails = Message_1.getMissingRequiredPropDetails;
exports.getUnknownPropDetails = Message_1.getUnknownPropDetails;
exports.getUnknownTypeDetails = Message_1.getUnknownTypeDetails;
// Use dependency injection to break circular dependencies created by
//  group -> convertMembersArray -> convertMember -> group  recursion
var convertMembersArray = helpers_1.convertMembersArrayWithConvertMember(convertMember);
var group = other_1.groupFromConvertMembersArray(convertMembersArray);
// All catalog member properties, except type and name which are assigned individually
exports.converters = new Map([
    ["group", group],
    ["wms", WmsCatalogItem_1.wmsCatalogItem],
    ["wms-getCapabilities", WmsCatalogGroup_1.wmsCatalogGroup],
    ["wfs-getCapabilities", other_1.webFeatureServerCatalogGroup],
    ["wps", Wps_1.wpsCatalogItem],
    ["wps-result", Wps_1.wpsResultItem],
    ["wps-getCapabilities", Wps_1.wpsCatalogGroup],
    ["csw", Csw_1.cswCatalogGroup],
    ["csv", CsvItem_1.csvCatalogItem],
    ["sos", other_1.sosCatalogItem],
    ["esri-mapServer", other_1.esriMapServerCatalogItem],
    ["esri-group", other_1.esriCatalogGroup],
    ["esri-mapServer-group", other_1.esriMapServerCatalogGroup],
    ["esri-featureServer", other_1.esriFeatureServerCatalogItem],
    ["ckan", Ckan_1.ckanCatalogGroup],
    ["ckan-resource", Ckan_1.ckanCatalogItem],
    ["geojson", other_1.geoJsonCatalogItem],
    ["carto", other_1.cartoMapCatalogItem],
    ["mvt", other_1.mapboxVectorTileCatalogItem],
    ["kml", other_1.kmlCatalogItem],
    ["socrata", other_1.socrataCatalogGroup],
]);
function convertMember(member, options) {
    var completeOptions = ConversionOptions_1.defaultOptions(options);
    if (helpers_1.isCatalogMember(member, completeOptions.partial)) {
        var converterForType = exports.converters.get(member.type);
        if (!converterForType) {
            return {
                member: null,
                messages: [Message_1.unknownType(member.type, member.name)],
            };
        }
        return converterForType(member, completeOptions);
    }
    else {
        var property = void 0, label = void 0;
        var m = member;
        if (is_1.default.string(m.type)) {
            property = "name";
            label = "<Invalid CatalogMember type = \"" + m.type + "\">";
        }
        else {
            property = "type";
            label = is_1.default.string(m.name) ? m.name : "<Invalid CatalogMember>";
        }
        return helpers_1.nullResult(Message_1.missingRequiredProp(Message_1.ModelType.Member, property, "string", label));
    }
}
exports.convertMember = convertMember;
// interface CatalogFile {
//   catalog: CatalogMember[];
// }
function convertCatalog(json, options) {
    var completeOptions = ConversionOptions_1.defaultOptions(options);
    if (!is_1.default.plainObject(json)) {
        return {
            result: null,
            messages: [Message_1.inputNotPlainObject()],
        };
    }
    var messages = [];
    var catalog;
    var workbench;
    if (is_1.default.array(json.catalog)) {
        var enabledItemsAccumulator = [];
        var res = convertMembersArray(json.catalog, "catalog", __assign(__assign({}, completeOptions), { enabledItemsAccumulator: enabledItemsAccumulator }));
        catalog = res.members;
        messages.push.apply(messages, res.messages);
        // Collect ids of enabled items, genearting a random id if required.
        workbench = enabledItemsAccumulator
            .map(function (item) {
            if (!item.id)
                item.id = generateRandomId_1.default(completeOptions.idLength);
            return item.id;
        })
            .filter(function (id) { return id !== undefined; });
    }
    if (completeOptions.addv7autoIdShareKeys) {
        // Add v7 autoIDs to shareLinks
        // v7 autoID has format Root Group/$someContainerId/$someLowerContainerId/$catalogName
        var addv7autoIdShareKey_1 = function (member, shareKey) {
            if (shareKey === void 0) { shareKey = "Root Group"; }
            var currentShareKey = shareKey + "/" + member.name;
            Array.isArray(member.shareKeys)
                ? member.shareKeys.push(currentShareKey)
                : (member.shareKeys = [currentShareKey]);
            if ("members" in member && Array.isArray(member.members)) {
                member.members.forEach(function (groupMember) {
                    return addv7autoIdShareKey_1(groupMember, currentShareKey);
                });
            }
        };
        catalog === null || catalog === void 0 ? void 0 : catalog.forEach(function (member) { return addv7autoIdShareKey_1(member); });
    }
    var result = {
        result: {
            workbench: workbench,
            catalog: catalog,
        },
        messages: messages,
    };
    helpers_1.copyProps(json, result.result, ["corsDomains", "homeCamera"]);
    if (completeOptions.copyUnknownProperties) {
        var unknownProps = helpers_1.getUnknownProps(json, [
            "catalog",
            "corsDomains",
            "homeCamera",
        ]);
        helpers_1.copyProps(json, result.result, unknownProps);
    }
    return result;
}
exports.convertCatalog = convertCatalog;
function convertShare(json) {
    var _a;
    if (!is_1.default.plainObject(json)) {
        return {
            result: null,
            messages: [Message_1.inputNotPlainObject()],
        };
    }
    // If version 8 return
    if ("version" in json &&
        typeof json.version === "string" &&
        json.version.startsWith("8")) {
        return { result: json, converted: false };
    }
    if (!Array.isArray(json.initSources)) {
        return {
            result: null,
            messages: [
                Message_1.missingRequiredProp(Message_1.ModelType.Share, "initSources", undefined, "Init sources"),
            ],
        };
    }
    var messages = [];
    var initializationUrls = [];
    // Crunch v7 initSources together + extract initializationUrls
    var v7InitSource = json.initSources.reduce(function (sources, current) {
        if (typeof current === "string") {
            initializationUrls.push(current);
            return sources;
        }
        return lodash_1.merge(sources, current);
    }, {});
    var v8InitSource = { stratum: "user" };
    var workbenchIds = [];
    var convertMembers = function (members, convertUserAdded) {
        if (convertUserAdded === void 0) { convertUserAdded = false; }
        return Object.entries(members).reduce(function (convertedMembers, _a) {
            var v7id = _a[0], v7Member = _a[1];
            if (is_1.default.plainObject(v7Member)) {
                // Get `knownContainerUniqueIds` from v7 `parents` property
                var knownContainerUniqueIds = ["/"];
                if (Array.isArray(v7Member.parents) && v7Member.parents.length > 0) {
                    knownContainerUniqueIds = v7Member.parents
                        .map(function (parent) {
                        // Convert v7 user added data group id
                        if (parent === "Root Group/User-Added Data") {
                            return "__User-Added_Data__";
                        }
                        // Convert v7 root group id
                        if (parent === "Root Group") {
                            return "/";
                        }
                        // Replace v7 autoID
                        return parent;
                    })
                        .filter(function (parent) { return typeof parent !== "undefined"; });
                }
                // Use model id if it is defined, otherwise use key from members object
                var newId_1 = typeof v7Member.id === "string" && v7Member.id !== ""
                    ? v7Member.id
                    : v7id;
                // Replace User Added Data group id
                if (v7id === "Root Group/User-Added Data") {
                    newId_1 = "__User-Added_Data__";
                }
                // For some reason user added data doesn't have "__User-Added_Data__" in v8 autoIDs, whereas v7 autoIDs start with `Root Group/User-Added Data`,
                // so remove all mentions of Root Group/User-Added Data from v7 autoIDs
                newId_1 = newId_1.replace("Root Group/User-Added Data", "");
                // Add member to workbench if isEnabled
                if (v7Member.isEnabled && !workbenchIds.find(function (w) { return w.id === newId_1; })) {
                    workbenchIds.push({
                        id: newId_1,
                        index: typeof v7Member.nowViewingIndex === "number"
                            ? v7Member.nowViewingIndex
                            : undefined,
                    });
                }
                // Only convert user added data if convertUserAdded is true
                if (convertUserAdded ||
                    (v7id !== "Root Group/User-Added Data" &&
                        !knownContainerUniqueIds.includes("__User-Added_Data__"))) {
                    var enabledItemsAccumulator = [];
                    var result = convertMember(v7Member, {
                        partial: true,
                        generateIds: false,
                        enabledItemsAccumulator: enabledItemsAccumulator,
                    });
                    // Add any missed members to workbench (eg in nested groups)
                    // This is useful for shareData which only has `catalog` property and not a `sharedCatalogMembers` property (eg CKAN preview plugin)
                    enabledItemsAccumulator.forEach(function (member) {
                        var _a;
                        // If no id - just guess using name
                        var id = (_a = member.id) !== null && _a !== void 0 ? _a : "/" + member.name;
                        if (!workbenchIds.find(function (w) { return w.id === id; })) {
                            workbenchIds.push({ id: id, index: undefined });
                        }
                    });
                    messages.push.apply(messages, result.messages);
                    convertedMembers[newId_1] = __assign(__assign({}, result.member), { knownContainerUniqueIds: knownContainerUniqueIds });
                }
                return convertedMembers;
            }
        }, {});
    };
    // Shared catalog members
    if ("sharedCatalogMembers" in v7InitSource) {
        v8InitSource.models = convertMembers(v7InitSource.sharedCatalogMembers);
    }
    else {
        v8InitSource.models = {};
    }
    // User added data
    if ("catalog" in v7InitSource && Array.isArray(v7InitSource.catalog)) {
        // Only add "Root Group/User-Added Data" Catalog Group
        var userAddedData = v7InitSource.catalog.find(function (item) {
            return item.id === "Root Group/User-Added Data" ||
                item.name === "User-Added Data";
        });
        if (typeof userAddedData !== "undefined" &&
            Array.isArray(userAddedData.items) &&
            userAddedData.items.length > 0) {
            // Delete all ids
            delete userAddedData.id;
            var deleteIds_1 = function (items) {
                return items.forEach(function (item) {
                    if (typeof item.id === "string")
                        delete item.id;
                    if (Array.isArray(item.items))
                        deleteIds_1(item.items);
                });
            };
            deleteIds_1(userAddedData.items);
            var userAddedDataV8 = convertMembers({
                "Root Group/User-Added Data": userAddedData,
            }, true);
            // Add IDs to user added models - so they show up in the workbenck (from sharedCatalogMembers)
            (_a = userAddedDataV8 === null || userAddedDataV8 === void 0 ? void 0 : userAddedDataV8["__User-Added_Data__"]) === null || _a === void 0 ? void 0 : _a.members.forEach(function (member) { var _a; return member !== null && (member.id = (_a = member.id) !== null && _a !== void 0 ? _a : "/" + member.name); });
            v8InitSource.models = __assign(__assign({}, userAddedDataV8), v8InitSource.models);
        }
    }
    if ("stories" in v7InitSource && Array.isArray(v7InitSource.stories)) {
        v8InitSource.stories = v7InitSource.stories.map(function (story) {
            var _a;
            var result = convertShare(story.shareData);
            // Add story details to message paths
            messages.push.apply(messages, (((_a = result.messages) === null || _a === void 0 ? void 0 : _a.map(function (message) {
                return __assign(__assign({}, message), { path: __spreadArrays(["Story", story.title], message.path) });
            })) || []));
            return __assign(__assign({}, story), { shareData: result.result });
        });
    }
    v8InitSource.workbench = workbenchIds
        .sort(function (a, b) { var _a; return typeof a.index !== "undefined" ? a.index - ((_a = b.index) !== null && _a !== void 0 ? _a : a.index + 1) : 1; })
        .map(function (item) { return item.id; });
    // Copy over common properties
    [
        "initialCamera",
        "homeCamera",
        "baseMapName",
        "viewerMode",
        "currentTime",
        "showSplitter",
        "splitPosition",
        "previewedItemId",
    ].forEach(function (prop) { return (v8InitSource[prop] = v7InitSource[prop]); });
    var v8json = {
        version: "8.0.0",
        initSources: __spreadArrays(initializationUrls, [v8InitSource]),
    };
    return { result: v8json, messages: messages, converted: true };
}
exports.convertShare = convertShare;
//# sourceMappingURL=convert.js.map