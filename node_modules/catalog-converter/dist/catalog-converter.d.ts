import { Func } from '@iadvize-oss/foldable-helpers/dist/types';
import { Opaque } from '@iadvize-oss/opaque-type';

declare enum Severity {
    Error = 0,
    Warning = 1
}
declare enum ModelType {
    Share = "Share",
    Member = "CatalogMember",
    Group = "CatalogGroup",
    WmsItem = "WebMapServiceCatalogItem",
    WmsGroup = "WebMapServiceCatalogGroup",
    WfsGroup = "WebFeatureServiceCatalogGroup",
    CsvItem = "CsvCatalogItem",
    SosItem = "SensorObservationServiceCatalogItem",
    CswCatalogGroup = "CswCatalogGroup",
    EsriCatalogGroup = "EsriCatalogGroup",
    EsriMapServerGroup = "EsriMapServerGroup",
    EsriMapServerItem = "EsriMapServerCatalogItem",
    EsriFeatureServerItem = "EsriFeatureServerCatalogItem",
    WpsItem = "WpsItem",
    WpsResultItem = "WpsResultItem",
    WpsGroup = "WpsGroup",
    CkanGroup = "CkanCatalogGroup",
    CkanCatalogItem = "CkanCatalogItem",
    GeoJsonItem = "GeoJsonCatalogItem",
    CartoMapCatalogItem = "CartoMapCatalogItem",
    MapboxVectorTileCatalogItem = "MapboxVectorTileCatalogItem",
    KmlCatalogItem = "KmlCatalogItem",
    SocrataCatalogGroup = "SocrataCatalogGroup"
}
interface MessageBase {
    readonly message: string;
    readonly path: string[];
    readonly severity: Severity;
}
interface UnknownPropDetails {
    readonly modelType: ModelType;
    readonly property: string;
}
interface MissingRequiredPropDetails {
    readonly modelType: ModelType;
    readonly property: string | string[];
    readonly requiredType?: string;
}
interface UnknownTypeDetails {
    readonly type: string;
}
interface InputNotPlainObjectDetails {
}
declare const unknownPropOpaque: {
    toOpaque: (value: UnknownPropDetails) => Opaque<"UnknownProp">;
    fromOpaque: (opaque: Opaque<"UnknownProp">) => UnknownPropDetails;
    isOpaque: (thing: any) => thing is Opaque<"UnknownProp">;
};
interface UnknownProp extends MessageBase {
    details: ReturnType<typeof unknownPropOpaque.toOpaque>;
}
declare const missingRequiredPropOpaque: {
    toOpaque: (value: MissingRequiredPropDetails) => Opaque<"MissingRequiredProp">;
    fromOpaque: (opaque: Opaque<"MissingRequiredProp">) => MissingRequiredPropDetails;
    isOpaque: (thing: any) => thing is Opaque<"MissingRequiredProp">;
};
interface MissingRequiredProp extends MessageBase {
    details: ReturnType<typeof missingRequiredPropOpaque.toOpaque>;
}
declare const unknownTypeOpaque: {
    toOpaque: (value: UnknownTypeDetails) => Opaque<"UnknownType">;
    fromOpaque: (opaque: Opaque<"UnknownType">) => UnknownTypeDetails;
    isOpaque: (thing: any) => thing is Opaque<"UnknownType">;
};
interface UnknownType extends MessageBase {
    details: ReturnType<typeof unknownTypeOpaque.toOpaque>;
}
declare const inputNotPlainObjectOpaque: {
    toOpaque: (value: InputNotPlainObjectDetails) => Opaque<"InputNotPlainObject">;
    fromOpaque: (opaque: Opaque<"InputNotPlainObject">) => InputNotPlainObjectDetails;
    isOpaque: (thing: any) => thing is Opaque<"InputNotPlainObject">;
};
interface InputNotPlainObject extends MessageBase {
    details: ReturnType<typeof inputNotPlainObjectOpaque.toOpaque>;
}
declare type Message = UnknownProp | MissingRequiredProp | UnknownType | InputNotPlainObject;
declare function getUnknownPropDetails(m: UnknownProp): UnknownPropDetails;
declare function getMissingRequiredPropDetails(m: MissingRequiredProp): MissingRequiredPropDetails;
declare function getUnknownTypeDetails(m: UnknownType): UnknownTypeDetails;
declare function getInputNotPlainObjectDetails(m: InputNotPlainObject): InputNotPlainObjectDetails;
declare const foldMessage: {
    <R>(funcs: {
        isUnknownProp: Func<UnknownProp, R>;
        isUnknownType: Func<UnknownType, R>;
        isMissingRequiredProp: Func<MissingRequiredProp, R>;
        isInputNotPlainObject: Func<InputNotPlainObject, R>;
    }): (s: Message) => R;
    <R_1, S extends Message>(funcs: {
        isUnknownProp: Func<Extract<S, UnknownProp>, R_1>;
        isUnknownType: Func<Extract<S, UnknownType>, R_1>;
        isMissingRequiredProp: Func<Extract<S, MissingRequiredProp>, R_1>;
        isInputNotPlainObject: Func<Extract<S, InputNotPlainObject>, R_1>;
    }): (s: S) => R_1;
};

declare type PlainObject = Record<string, unknown>;
interface CatalogMember extends PlainObject {
    type: string;
    name: string;
    id?: string;
    shareKeys?: string[];
}
interface MemberResult {
    member: CatalogMember | null;
    messages: Message[];
}

interface ConversionOptions {
    readonly copyUnknownProperties: boolean;
    readonly partial: boolean;
    readonly generateIds: boolean;
    readonly idLength: number;
    readonly enabledItemsAccumulator: CatalogMember[] | undefined;
    readonly addv7autoIdShareKeys: boolean;
}

declare type Converter = (item: CatalogMember, options: ConversionOptions) => MemberResult;
declare const converters: Map<string, Converter>;
declare function convertMember(member: unknown, options?: Partial<ConversionOptions>): MemberResult;
interface CatalogResult {
    result: {
        catalog?: CatalogMember[];
        workbench?: string[];
    } | null;
    messages: Message[];
}
declare function convertCatalog(json: unknown, options?: Partial<ConversionOptions>): CatalogResult;
declare type Share = {
    version: string;
    initSources: any[];
};
declare type ShareResult = {
    result: Share | null;
    messages?: Message[];
    converted?: boolean;
};
declare type Story = {
    title: string;
    text: string;
    id: string;
    shareData: Share;
};
declare function convertShare(json: unknown): ShareResult;

export { CatalogResult, Converter, Share, ShareResult, Story, convertCatalog, convertMember, convertShare, converters, foldMessage, getInputNotPlainObjectDetails, getMissingRequiredPropDetails, getUnknownPropDetails, getUnknownTypeDetails };
