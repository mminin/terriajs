(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
    typeof define === 'function' && define.amd ? define(factory) :
    (global = global || self, global.threddsCrawler = factory());
}(this, (function () { 'use strict';

    class Requestor {

        constructor (urlParser, options, domparser) {
            this.parseUrl = urlParser;
            this.proxy = options.proxy ? options.proxy : null;
            this.DOMParser = domparser;
        }

        async getData (url) {
            url = this.proxy ? `${this.proxy}${url}` : url;
            const xmlResponse = await fetch(url);
            const responseXml = await xmlResponse.text();
            const json = this.parseStringSync(responseXml);
            return json
        }

        parseStringSync (str) {
            return parseXML(str, false, this.DOMParser)
        }

    }

    function parseXML(xml, extended, DomParser) {
        if (!xml) return {};

        function parseXML(node, simple) {
            if (!node) return null;
            let txt = '';
            let obj = null;
            let att = null;
            if (node.childNodes) {
                if (node.childNodes.length > 0) {
                    for (var n = 0; n < node.childNodes.length; ++n) {
                        const cn = node.childNodes[n];
                        const cnt = cn.nodeType;
                        const cnn = jsVar(cn.localName || cn.nodeName);
                        const cnv = cn.text || cn.nodeValue || '';
                        if (cnt === 8) {
                            continue;
                        } else if (cnt === 3 || cnt === 4 || !cnn) {
                            if (cnv.match(/^\s+$/)) {
                                continue;
                            }
                            txt += cnv.replace(/^\s+/, '').replace(/\s+$/, '');
                        } else {
                            obj = obj || {};
                            if (obj[cnn]) {
                                if (!obj[cnn].length) obj[cnn] = myArr(obj[cnn]);
                                obj[cnn] = myArr(obj[cnn]);

                                obj[cnn][obj[cnn].length] = parseXML(cn, true);
                                obj[cnn].length = obj[cnn].length;
                            } else {
                                obj[cnn] = parseXML(cn);
                            }
                        }
                    }
                }
            }
            if (node.attributes) {
                if (node.attributes.length > 0) {
                    att = {};
                    obj = obj || {};
                    for (var a = 0; a < node.attributes.length; ++a) {
                        let at = node.attributes[a];
                        let atn = jsVar(at.name);
                        let atv = at.value;
                        att[atn] = atv;
                        if (obj[atn]) {
                            obj[cnn] = myArr(obj[cnn]);

                            obj[atn][obj[atn].length] = atv;
                            obj[atn].length = obj[atn].length;
                        } else {
                            obj[atn] = atv;
                        }
                    }
                }
            }
            if (obj) {
                var newObj = txt !== '' ? new String(txt) : {};
                for (var prop in obj) {
                    if (obj.hasOwnProperty(prop)) {
                        newObj[prop] = obj[prop];
                    }
                }
                obj = newObj;
                txt = obj.text ? [obj.text || ''].concat([txt]) : txt;
                if (txt) obj.text = txt;
                txt = '';
            }
            var out = obj || txt;
            if (extended) {
                if (txt) out = {};
                txt = out.text || txt || '';
                if (txt) out.text = txt;
                if (!simple) out = myArr(out);
            }
            return out;
        }

        var jsVar = function(s) {
            return String(s || '').replace(/-/g, '_');
        };

        var myArr = function(o) {
            if (!Array.isArray(o)) o = [o];
            o.length = o.length;
            return o;
        };

        if (typeof xml === 'string') {
            const parser = new DomParser();
            xml = parser.parseFromString(xml, 'text/xml');
        }
        if (!xml.nodeType) return;
        if (xml.nodeType === 3 || xml.nodeType === 4) return xml.nodeValue;

        var root = xml.nodeType === 9 ? xml.documentElement : xml;

        var out = parseXML(root, true);

        xml = null;
        root = null;

        return out;
    }

    function parseUrl (url) {
        return new URL(url)
    }

    class Dataset {

        constructor (datasetJson, parent) {
            this.parent = parent;
            this.id = datasetJson.ID;
            this.name = datasetJson.name;
            this.urlPath = datasetJson.urlPath ? datasetJson.urlPath : null;

            this.dataType = datasetJson.dataType ? datasetJson.dataType : null;
            this.dataFormat = datasetJson.dataFormat ? datasetJson.dataFormat : null;

            if (datasetJson.dataSize) {
                this.dataSize = {
                    size: datasetJson.dataSize['#text'],
                    unit: datasetJson.dataSize.$units
                };
            } else {
                this.dataSize = null;
            }

            if (datasetJson.date) {
                this.date = {
                    size: datasetJson.date['#text'],
                    type: datasetJson.date.$type
                };
            } else {
                this.date = null;
            }

            this.isParentDataset = this.dataSize === null;
            this.datasets = [];
            this._datasetJson = datasetJson;

            this.catalogsAreLoaded = false;
            this.catalogs = [];
        }

        async getNestedDatasets () {
            const json = this._datasetJson;
            if (json.dataset) {
                if (!Array.isArray(json.dataset)) json.dataset = [json.dataset];
                for (let i = 0; i < json.dataset.length; i++) {
                    const ds = new Dataset(json.dataset[i], this);
                    await ds.getNestedDatasets();
                    this.datasets.push(ds);
                }
            }
        }

        async loadAllNestedCatalogs () {
            const json = this._datasetJson;
            if (json.catalogRef) {
                if (!Array.isArray(json.catalogRef)) json.catalogRef = [json.catalogRef];
                for (let i = 0; i < json.catalogRef.length; i++) {
                    const url = this._cleanUrl(json.catalogRef[i]['xlink:href']);
                    try {
                        const ci = new Catalog(url, json.catalogRef[i], this, this.parent._requestor);
                        await ci._loadCatalog();
                        this.catalogs.push(ci);
                    } catch (err) {
                        console.error(`Couldn't create catalog within dataset:
                        Dataset URL: ${url}
                        ${err}`
                        );
                    }
                }
            }
            this.catalogsAreLoaded = true;
        }

        // Could this be the same as Catalog._cleanUrl?
        _cleanUrl (url) {
            // If the url is absolute return it as is...
            if (url.indexOf('://') >= 0) return url

            // Assume there is only one "/" between _catalogBaseUrl and url.
            return `${this.parentCatalog._catalogBaseUrl}${url}`
        }

        get wmsUrl () {
            if (!this.supportsWms) return null
            // Assume there is only one "/" between wmsBase and urlPath.
            return `${this.parentCatalog.wmsBase}${this.urlPath}?service=WMS&version=1.3.0&request=GetCapabilities`
        }

        get ncssUrl () {
            if (!this.supportsNcss) return null
            return `${this.parentCatalog.ncssBase}${this.urlPath}`
        }

        get parentCatalog () {
            const p = this.parent;
            if (p.isParentDataset) {
                return p.parent
            }
            return p
        }

        get supportsWms () {
            if (this.isParentDataset) return false
            return this.parentCatalog.supportsWms
        }

        get supportsNcss () {
            if (this.isParentDataset) return false
            return this.parentCatalog.supportsNcss
        }

    }

    class Service {

        constructor (serviceJson) {
            this.name = serviceJson.name;
            this.type = serviceJson.serviceType;
            this.baseUrl = serviceJson.base;
        }

    }

    class Catalog {

        constructor (catalogUrl, catalogJson, parentCatalog, requestor) {
            this.url = catalogUrl;
            this.name = catalogJson !== null ? catalogJson.name : null;
            this.title = catalogJson !== null ? catalogJson['xlink:title'] : null;
            this.id = catalogJson !== null ? catalogJson.ID : null;
            this.isLoaded = false;
            this.datasets = [];
            this.catalogs = [];
            this.services = {};
            this.parentCatalog = parentCatalog;

            this._catalogJson = catalogJson;
            this._requestor = requestor;
            this._urlObj = requestor.parseUrl(this.url);

            this._catalogBaseUrl = this.url.replace('catalog.xml', '');
            this._rootUrl = `${this._urlObj.protocol}//${this._urlObj.host}`;
        }

        get hasDatasets () {
            return 'dataset' in this._catalogJson
        }

        get hasNestedCatalogs () {
            return 'catalogRef' in this._catalogJson
        }

        get supportsNcss () {
            return 'subsetServer' in this.services
        }

        get ncssBase () {
            if (!this.supportsNcss) return null
            return `${this._rootUrl}${this.services.subsetServer.baseUrl}`
        }

        get supportsWms () {
            return 'wms' in this.services
        }

        get wmsBase () {
            if (!this.supportsWms) return null
            return `${this._rootUrl}${this.services.wms.baseUrl}`
        }

        async _loadCatalog () {
            this._catalogJson = await this._requestor.getData(this.url);
            this.isLoaded = true;
            await this._processCatalog();
        }

        async _processCatalog () {
            const json = this._catalogJson;
            if (this.name === null || this.name === '') this.name = json.name;
            if (this.title === null || this.title === '') this.title = json['xlink:title'];
            if (this.id === null) this.id = json.ID;

            if (json.dataset) {
                if (!Array.isArray(json.dataset)) json.dataset = [json.dataset];
                for (var i = 0; i < json.dataset.length; i++) {
                    const ds = new Dataset(json.dataset[i], this);
                    await ds.getNestedDatasets();
                    this.datasets.push(ds);
                }
            }

            if (json.service) {
                this._getServicesRecursively(json.service);
            }

            if (json.catalogRef) {
                if (!Array.isArray(json.catalogRef)) json.catalogRef = [json.catalogRef];
                for (let i = 0; i < json.catalogRef.length; i++) {
                    const url = this._cleanUrl(json.catalogRef[i]['xlink:href']);
                    try {
                        const ci = new Catalog(url, json.catalogRef[i], this, this._requestor);
                        this.catalogs.push(ci);
                    } catch (err) {
                        console.error(`
                        Couldn't create catalog in catalog: ${url}
                        Parent was: ${this.url}
                        ${err}`
                        );
                    }
                }
            }
        }

        async loadAllNestedCatalogs () {
            for (let i = 0; i < this.catalogs.length; i++) {
                const catalog = this.catalogs[i];
                try {
                    await catalog._loadCatalog();
                    await catalog.loadAllNestedCatalogs();
                } catch (err) {
                    console.error(`
                    Couldn't create catalog in catalog: ${catalog.url}
                    Parent was: ${this.url}
                    ${err}`
                    );
                }
            }
        }

        async loadNestedCatalogById (id) {
            let catalogFound = false;
            for (let i = 0; i < this.catalogs.length; i++) {
                const catalog = this.catalogs[i];
                if (catalog.id !== id) continue
                catalogFound = true;
                try {
                    await catalog._loadCatalog();
                    return catalog
                } catch (err) {
                    console.error(`
                    Couldn't create catalog in catalog: ${catalog.url}
                    Parent was: ${this.url}
                    ${err}`
                    );
                }
            }
            if (!catalogFound) {
                throw new Error(`Could not find catalog using id: ${id}`)
            }
        }

        // Services can be nested so crawl recurssively.
        // This isn't ideal as theoretically a dataset might
        // have access to one set of services but not another,
        // eg a set of service might provide WMS access, while another set don't
        // This is part of the metadata available in the xml but it's fiddily
        _getServicesRecursively (serviceInfo) {
            if (Array.isArray(serviceInfo)) serviceInfo = serviceInfo[0];
            for (let i = 0; i < serviceInfo.service.length; i++) {
                const service = serviceInfo.service[i];
                if ('service' in service) this._getServicesRecursively(service);
                else {
                    const srv = new Service(service);
                    this.services[srv.name] = srv;
                }
            }
        }

        // Ay ya yai - THREDDS url references are the worst
        // A root catalog might be https://climate-services.it.csiro.au/thredds/catalog.xml
        //
        // And it might have       xlink:href="/thredds/catalog/data/nrm_ts/catalog.xml"
        // which should go to      https://climate-services.it.csiro.au/thredds/catalog/data/nrm_ts/catalog.xml
        //
        // And it also might have  xlink:href="aggregation/scaled_seasonal_timeseries.xml"
        // which should go to      https://climate-services.it.csiro.au/thredds/aggregation/scaled_seasonal_timeseries.xml
        _cleanUrl (url) {
            // If the url is absolute go directly to it.
            // This case is not covered by tests.
            if (url.indexOf('://') >= 0) return url

            // Sometimes urls seems to extend from the current catalog.
            // Assume that the url has no leading "/".
            // This case is not covered by tests.
            if (url.indexOf('thredds') === -1) {
                return `${this._catalogBaseUrl}/${url}`
            }

            // Sometimes the url reference seems to reference the root of the thredds server.
            // Assume that the url has a leading "/".
            return `${this._rootUrl}${url}`
        }

        getAllChildDatasets () {
            let ds = [];
            for (var i = 0; i < this.catalogs.length; i++) {
                ds = ds.concat(this.catalogs[i].getAllChildDatasets());
            }
            for (let i = 0; i < this.datasets.length; i++) {
                if (this.datasets[i].isParentDataset) {
                    for (var ii = 0; ii < this.datasets[i].datasets.length; ii++) {
                        ds.push(this.datasets[i].datasets[ii]);
                    }
                } else {
                    ds.push(this.datasets[i]);
                }
            }
            return ds
        }

    }

    async function threddsCatalogCrawler (url, requestor) {
        const catalog = new Catalog(url, null, null, requestor);
        await catalog._loadCatalog();
        return catalog
    }

    async function entry (url, options) {
        options = options == null ? {} : options;
        if ('proxy' in options) {
            options.proxy = options.proxy.slice(-1) === '/' ? options.proxy : options.proxy + '/';
        }

        const requestor = new Requestor(parseUrl, options, DOMParser);
        const c = await threddsCatalogCrawler(url, requestor);
        return c
    }

    return entry;

})));
